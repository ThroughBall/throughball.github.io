{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/09/24/hello-world/"},{"title":"归并排序实现","text":"luogu博客食用 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#define MAXN 100005using namespace std;int n, a[MAXN], b[MAXN];void merge(int a_left, int a_right, int b_left, int b_right){ int number = a_left; int left = a_left; while (a_left &lt;= a_right &amp;&amp; b_left &lt;= b_right){ if (a[a_left] &lt;= a[b_left]) b[number++] = a[a_left++]; else b[number++] = a[b_left++]; } if (a_left &lt;= a_right) for (int i = number;i &lt;= b_right; ++i) b[i] = a[a_left++]; else if (b_left &lt;= b_right) for (int i = number;i &lt;= b_right; ++i) b[i] = a[b_left++]; for (int i = left; i &lt;= b_right; ++i) a[i] = b[i];}void mergesort(int left, int right){ if (left &lt; right){ int mid = left + right &gt;&gt; 1; mergesort(left, mid); mergesort(mid + 1, right); merge(left, mid, mid + 1, right); }}int main(){ cin &gt;&gt; n; for (int i = 1;i &lt;= n; ++i) cin &gt;&gt; a[i]; mergesort(1,n); for (int i = 1;i &lt;= n; ++i) cout &lt;&lt; b[i] &lt;&lt; &quot; &quot; ; return 0;}","link":"/2023/10/01/mergesort/"},{"title":"spfa实现","text":"luogu博客食用 采用vector + 结构体 + spfa的spfa模板 同时也是洛谷P3371的题解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define MAXN 10005#define inf 2147483647 // 如果没有通路，就输出2^31-1using namespace std;struct Node{ int to; // 边的指向 int val; // 边的长度};int dis[MAXN], vis[MAXN];int n, m, s, u, v, w, tot;queue &lt;int&gt; q;vector &lt;Node&gt; edge[MAXN];Node t;void spfa(){ for (int i = 1; i &lt;= n; ++i) dis[i] = inf; // 如果没有通路，就输出2^31-1 q.push(s); dis[s] = 0; // 初始化：把s点作为起点，s点到s点的距离为0 while(q.size()){ int u = q.front(); q.pop(); vis[u] = false; // 取出队首，把队首从队列q中弹出并标记 for (int i = 0; i &lt; edge[u].size(); ++i){ if (dis[edge[u][i].to] &gt; dis[u] + edge[u][i].val){ dis[edge[u][i].to] = dis[u] + edge[u][i].val; // 更新到edge[u][i].to点的距离 if (vis[edge[u][i].to] == false){ vis[edge[u][i].to] = true; q.push(edge[u][i].to); // 如果不在队列q中则加入队列q并标记 } } } }}int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1; i &lt;= m; ++i){ cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; t.to = v; t.val = w; edge[u].push_back(t); // 添加一条有向边 } spfa(); for (int i = 1; i &lt;= n; ++i){ cout &lt;&lt; dis[i] &lt;&lt; &quot; &quot;; // 输出从s点到各点的最短路径 } return 0;}","link":"/2023/10/01/spfa/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"OI备忘录","slug":"OI备忘录","link":"/tags/OI%E5%A4%87%E5%BF%98%E5%BD%95/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"}],"pages":[{"title":"About Me","text":"一直很菜的信竞选手，爱看书。 在沉重的世界中幻化成轻逸的飞鸟。 ThroughBall 的个人中心 - 洛谷 ThroughBall · GitHub OI备忘录 - 洛谷博客 Throughball - Codeforces I went to the woods because I wished to live deliberately, to front only the essential facts of life, and see if I could not learn what it had to teach, and not, when I came to die, discover that I had not lived.","link":"/about/index.html"}]}