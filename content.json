{"posts":[{"title":"JOI 2017 Final 足球 题解","text":"luogu题目链接 首先我们注意到运球和移动的疲劳度都是C，而对于运球和控球，人和球都是想向哪走向哪走 考虑踢球的疲劳度$A×p+B$，我们看作从非踢球状态转变为踢球状态要消耗疲劳度B，此后两点之间的球消耗A 对于没有人控制的球，它在没有受到球员作用下，要么连续横向移动，要么连续竖向移动 基于以上的性质，我们考虑建三个点 控球（０层） 传球时横向移动（１层） 传球时纵向移动（２层） 对于上下左右相邻的点，我们建以下的边 运球的边$(C)$ 横向移动的边$(A)$ 纵向移动的边$(A)$ 对于点和自己，我们建以下的边 从非踢球状态转变为踢球状态$(B)$ 最近的球员来接这个球$(dis×C)$ 接下来就变成最短路问题了 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt; #include &lt;map&gt;#include &lt;cstring&gt;#define MAXN 100005#define int long long#define MAXH 505using namespace std;int h, w, a, b, c, n, x[MAXN], y[MAXN], cnt;int dis[MAXH][MAXH], dist[MAXH * MAXH * 3];int dij[MAXH * MAXH * 3];int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};bool vis[MAXH][MAXH], vis2[MAXH * MAXH * 3];struct Dist{ int disx; int disy;};struct Node{ int id, d; bool operator &lt; (const Node &amp;x) const{ return d &gt; x.d; }};queue &lt;Dist&gt; q;priority_queue &lt;Node&gt; pq;vector &lt;pair&lt;int, int&gt;&gt; G[MAXH * MAXH * 3];map &lt;tuple&lt;int, int, int&gt;, int&gt; mp;tuple &lt;int, int, int&gt; t[MAXH * MAXH * 3], get_t;bool judge(int ax, int ay){ return ((ax &gt;= 0) &amp;&amp; (ax &lt;= h) &amp;&amp; (ay &gt;= 0) &amp;&amp; (ay &lt;= w));}int getid(int ax, int ay, int f){ if (!mp[make_tuple(ax, ay, f)]){ mp[make_tuple(ax, ay, f)] = ++cnt; t[cnt] = make_tuple(ax, ay, f); } return mp[make_tuple(ax, ay, f)];}void Manhattan_Distance(){ for (int i = 0; i &lt;= h; ++i){ for (int j = 0; j &lt;= w; ++j){ dis[i][j] = 0x7fffffff; } } for (int i = 1; i &lt;= n; ++i){ dis[x[i]][y[i]] = 0; q.push((Dist){x[i], y[i]}); } while(q.size()){ int tbx = q.front().disx; int tby = q.front().disy; q.pop(); vis[tbx][tby] = false; for (int i = 0; i &lt; 4; ++i){ int cntx = tbx + dx[i]; int cnty = tby + dy[i]; if (judge(cntx, cnty) &amp;&amp; dis[cntx][cnty] &gt; dis[tbx][tby] + 1){ dis[cntx][cnty] = dis[tbx][tby] + 1; if (!vis[cntx][cnty]){ q.push((Dist){cntx, cnty}); vis[cntx][cnty] = true; } } } }}void Build_Map(){ for (int i = 0; i &lt;= h; ++i){ for (int j = 0; j &lt;= w; ++j){ int tbid0 = getid(i, j, 0); int tbid1 = getid(i, j, 1); int tbid2 = getid(i, j, 2); for (int k = 0; k &lt; 4; ++k){ int cntx = i + dx[k]; int cnty = j + dy[k]; if (judge(cntx, cnty)){ G[tbid0].push_back(make_pair(getid(cntx, cnty, 0), c)); } } for (int k = 0; k &lt; 2; ++k){ int cntx = i + dx[k]; int cnty = j + dy[k]; if (judge(cntx, cnty)){ G[tbid1].push_back(make_pair(getid(cntx, cnty, 1), a)); } } for (int k = 2; k &lt; 4; ++k){ int cntx = i + dx[k]; int cnty = j + dy[k]; if (judge(cntx, cnty)){ G[tbid2].push_back(make_pair(getid(cntx, cnty, 2), a)); } } G[tbid0].push_back(make_pair(tbid1, b)); G[tbid0].push_back(make_pair(tbid2, b)); G[tbid1].push_back(make_pair(tbid0, dis[i][j] * c)); G[tbid2].push_back(make_pair(tbid0, dis[i][j] * c)); } }}void Dijkstra(){ for (int i = 1; i &lt;= cnt; ++i) dist[i] = 4e18; int tbid = getid(x[1], y[1], 0); dist[tbid] = 0; pq.push((Node){tbid, 0}); while(pq.size()){ int idcnt = pq.top().id; pq.pop(); if (vis2[idcnt]) continue; vis2[idcnt] = true; for (unsigned int i = 0; i &lt; G[idcnt].size(); ++i){ int idnum = G[idcnt][i].first; int tbdis = G[idcnt][i].second; if (dist[idcnt] + tbdis &lt; dist[idnum]){ dist[idnum] = dist[idcnt] + tbdis; get_t = t[idnum]; pq.push((Node){getid(get&lt;0&gt;(get_t), get&lt;1&gt;(get_t), get&lt;2&gt;(get_t)), dist[idnum]}); } } }}signed main(){ scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;, &amp;h, &amp;w, &amp;a, &amp;b, &amp;c, &amp;n); for (int i = 1; i &lt;= n; ++i){ scanf(&quot;%lld%lld&quot;, &amp;x[i], &amp;y[i]); } Manhattan_Distance(); Build_Map(); Dijkstra(); printf(&quot;%lld&quot;, min(min(dist[getid(x[n], y[n], 0)], dist[getid(x[n], y[n], 1)]), dist[getid(x[n], y[n], 2)])); return 0;}","link":"/2023/11/26/P5100/"},{"title":"P9541 「AWOI Round 2 D」数字三角形 题解","text":"寒假第一题 XD luogu题目链接 不难想到，三角形旋转三遍之后就复原了，而且旋转会加消耗值，所以旋转次数越少越好 那么就只有三种情况，不旋转，旋转一次和旋转两次 给一个三角形，不考虑旋转，按照题意最小消耗值是多少呢？ 因为想要经过数之和最大，所以如果经过一个不是该行最大值的点，那就要消耗1个单位，用来把最大值和那个点交换 如果经过的点本来就是该行最大值，那就不需要交换，也不需要加消耗值 所以这题虽然看着像原版数字三角形，但其实是一个每个点不是0（是该行最大值）就是1（不是该行最大值）的数字三角形问题 在计算完三角形的消耗值后，我们旋转，再计算，再旋转，再计算 不过注意本题路径经过数之和优先，只有在经过数之和相同的情况下，才会比较消耗值 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define MAXN 1005using namespace std;int tri[MAXN][MAXN], ans_sum, ans_exp, maxtri[MAXN], dp[MAXN][MAXN], n, newtri[MAXN][MAXN];int init() { int sum = 0; memset(maxtri, 0, sizeof(maxtri)); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= i; ++j) { dp[i][j] = 0; } } for (int i = 1; i &lt;= n; ++i) { maxtri[i] = -1; for (int j = 1; j &lt;= i; ++j) { if (tri[i][j] &gt; maxtri[i]) { maxtri[i] = tri[i][j]; } } sum += maxtri[i]; } return sum;} // 初始化，记录每一行的最大值int solve() { for (int i = n - 1; i &gt;= 1; --i) { for (int j = 1; j &lt;= i; ++j) { dp[i][j] = min(dp[i + 1][j] + (maxtri[i + 1] == tri[i + 1][j] ? 0 : 1), dp[i + 1][j + 1] + (maxtri[i + 1] == tri[i + 1][j + 1] ? 0 : 1)); // 如果最大值是该点，就不消耗，否则就+1 } } return dp[1][1];} // 动态规划求三角形中最小消耗void rotate() { for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= i; ++j) { newtri[j - i + n][n - i + 1] = tri[i][j]; } } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= i; ++j) { tri[i][j] = newtri[i][j]; } }} // 模拟三角形旋转int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= i; ++j) { cin &gt;&gt; tri[i][j]; } } for (int i = 1; i &lt;= 3; ++i) { if (init() &gt; ans_sum) { ans_sum = init(); ans_exp = (i - 1) * n + solve(); } else if (init() == ans_sum) { ans_exp = min(ans_exp, (i - 1) * n + solve()); } // 先考虑数字和，数字和相同再比较消耗 rotate(); } cout &lt;&lt; ans_sum &lt;&lt; &quot; &quot; &lt;&lt; ans_exp &lt;&lt; endl; return 0;}","link":"/2024/01/31/P9541/"}],"tags":[{"name":"JOI","slug":"JOI","link":"/tags/JOI/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"OI备忘录","slug":"OI备忘录","link":"/tags/OI%E5%A4%87%E5%BF%98%E5%BD%95/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"}],"pages":[{"title":"About Me","text":"在沉重的世界里幻化成轻逸的飞鸟。 个人邮箱：throughball1@outlook.com 其他平台的账号： ThroughBall 的个人中心 - 洛谷 ThroughBall · GitHub Throughball - Codeforces Throughball - Atcoder","link":"/about/index.html"}]}