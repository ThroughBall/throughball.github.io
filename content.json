{"posts":[{"title":"P5100","text":"题目链接 首先我们注意到运球和移动的疲劳度都是C，而对于运球和控球，人和球都是想向哪走向哪走 考虑踢球的疲劳度$A×p+B$，我们看作从非踢球状态转变为踢球状态要消耗疲劳度B，此后两点之间的球消耗A 对于没有人控制的球，它在没有受到球员作用下，要么连续横向移动，要么连续竖向移动 基于以上的性质，我们考虑建三个点 控球（０层） 传球时横向移动（１层） 传球时纵向移动（２层） 对于上下左右相邻的点，我们建以下的边 运球的边$(C)$ 横向移动的边$(A)$ 纵向移动的边$(A)$ 对于点和自己，我们建以下的边 从非踢球状态转变为踢球状态$(B)$ 最近的球员来接这个球$(dis×C)$ 接下来就变成最短路问题了 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt; #include &lt;map&gt;#include &lt;cstring&gt;#define MAXN 100005#define int long long#define MAXH 505using namespace std;int h, w, a, b, c, n, x[MAXN], y[MAXN], cnt;int dis[MAXH][MAXH], dist[MAXH * MAXH * 3];int dij[MAXH * MAXH * 3];int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};bool vis[MAXH][MAXH], vis2[MAXH * MAXH * 3];struct Dist{ int disx; int disy;};struct Node{ int id, d; bool operator &lt; (const Node &amp;x) const{ return d &gt; x.d; }};queue &lt;Dist&gt; q;priority_queue &lt;Node&gt; pq;vector &lt;pair&lt;int, int&gt;&gt; G[MAXH * MAXH * 3];map &lt;tuple&lt;int, int, int&gt;, int&gt; mp;tuple &lt;int, int, int&gt; t[MAXH * MAXH * 3], get_t;bool judge(int ax, int ay){ return ((ax &gt;= 0) &amp;&amp; (ax &lt;= h) &amp;&amp; (ay &gt;= 0) &amp;&amp; (ay &lt;= w));}int getid(int ax, int ay, int f){ if (!mp[make_tuple(ax, ay, f)]){ mp[make_tuple(ax, ay, f)] = ++cnt; t[cnt] = make_tuple(ax, ay, f); } return mp[make_tuple(ax, ay, f)];}void Manhattan_Distance(){ for (int i = 0; i &lt;= h; ++i){ for (int j = 0; j &lt;= w; ++j){ dis[i][j] = 0x7fffffff; } } for (int i = 1; i &lt;= n; ++i){ dis[x[i]][y[i]] = 0; q.push((Dist){x[i], y[i]}); } while(q.size()){ int tbx = q.front().disx; int tby = q.front().disy; q.pop(); vis[tbx][tby] = false; for (int i = 0; i &lt; 4; ++i){ int cntx = tbx + dx[i]; int cnty = tby + dy[i]; if (judge(cntx, cnty) &amp;&amp; dis[cntx][cnty] &gt; dis[tbx][tby] + 1){ dis[cntx][cnty] = dis[tbx][tby] + 1; if (!vis[cntx][cnty]){ q.push((Dist){cntx, cnty}); vis[cntx][cnty] = true; } } } }}void Build_Map(){ for (int i = 0; i &lt;= h; ++i){ for (int j = 0; j &lt;= w; ++j){ int tbid0 = getid(i, j, 0); int tbid1 = getid(i, j, 1); int tbid2 = getid(i, j, 2); for (int k = 0; k &lt; 4; ++k){ int cntx = i + dx[k]; int cnty = j + dy[k]; if (judge(cntx, cnty)){ G[tbid0].push_back(make_pair(getid(cntx, cnty, 0), c)); } } for (int k = 0; k &lt; 2; ++k){ int cntx = i + dx[k]; int cnty = j + dy[k]; if (judge(cntx, cnty)){ G[tbid1].push_back(make_pair(getid(cntx, cnty, 1), a)); } } for (int k = 2; k &lt; 4; ++k){ int cntx = i + dx[k]; int cnty = j + dy[k]; if (judge(cntx, cnty)){ G[tbid2].push_back(make_pair(getid(cntx, cnty, 2), a)); } } G[tbid0].push_back(make_pair(tbid1, b)); G[tbid0].push_back(make_pair(tbid2, b)); G[tbid1].push_back(make_pair(tbid0, dis[i][j] * c)); G[tbid2].push_back(make_pair(tbid0, dis[i][j] * c)); } }}void Dijkstra(){ for (int i = 1; i &lt;= cnt; ++i) dist[i] = 4e18; int tbid = getid(x[1], y[1], 0); dist[tbid] = 0; pq.push((Node){tbid, 0}); while(pq.size()){ int idcnt = pq.top().id; pq.pop(); if (vis2[idcnt]) continue; vis2[idcnt] = true; for (unsigned int i = 0; i &lt; G[idcnt].size(); ++i){ int idnum = G[idcnt][i].first; int tbdis = G[idcnt][i].second; if (dist[idcnt] + tbdis &lt; dist[idnum]){ dist[idnum] = dist[idcnt] + tbdis; get_t = t[idnum]; pq.push((Node){getid(get&lt;0&gt;(get_t), get&lt;1&gt;(get_t), get&lt;2&gt;(get_t)), dist[idnum]}); } } }}signed main(){ scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;, &amp;h, &amp;w, &amp;a, &amp;b, &amp;c, &amp;n); for (int i = 1; i &lt;= n; ++i){ scanf(&quot;%lld%lld&quot;, &amp;x[i], &amp;y[i]); } Manhattan_Distance(); Build_Map(); Dijkstra(); printf(&quot;%lld&quot;, min(min(dist[getid(x[n], y[n], 0)], dist[getid(x[n], y[n], 1)]), dist[getid(x[n], y[n], 2)])); return 0;}","link":"/2023/11/26/P5100/"},{"title":"归并排序实现","text":"luogu博客食用 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#define MAXN 100005using namespace std;int n, a[MAXN], b[MAXN];void merge(int a_left, int a_right, int b_left, int b_right){ int number = a_left; int left = a_left; while (a_left &lt;= a_right &amp;&amp; b_left &lt;= b_right){ if (a[a_left] &lt;= a[b_left]) b[number++] = a[a_left++]; else b[number++] = a[b_left++]; } if (a_left &lt;= a_right) for (int i = number;i &lt;= b_right; ++i) b[i] = a[a_left++]; else if (b_left &lt;= b_right) for (int i = number;i &lt;= b_right; ++i) b[i] = a[b_left++]; for (int i = left; i &lt;= b_right; ++i) a[i] = b[i];}void mergesort(int left, int right){ if (left &lt; right){ int mid = left + right &gt;&gt; 1; mergesort(left, mid); mergesort(mid + 1, right); merge(left, mid, mid + 1, right); }}int main(){ cin &gt;&gt; n; for (int i = 1;i &lt;= n; ++i) cin &gt;&gt; a[i]; mergesort(1,n); for (int i = 1;i &lt;= n; ++i) cout &lt;&lt; b[i] &lt;&lt; &quot; &quot; ; return 0;}","link":"/2023/10/01/mergesort/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/09/24/hello-world/"},{"title":"spfa实现","text":"luogu博客食用 采用vector + 结构体 + spfa的spfa模板 同时也是洛谷P3371的题解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define MAXN 10005#define inf 2147483647 // 如果没有通路，就输出2^31-1using namespace std;struct Node{ int to; // 边的指向 int val; // 边的长度};int dis[MAXN], vis[MAXN];int n, m, s, u, v, w, tot;queue &lt;int&gt; q;vector &lt;Node&gt; edge[MAXN];Node t;void spfa(){ for (int i = 1; i &lt;= n; ++i) dis[i] = inf; // 如果没有通路，就输出2^31-1 q.push(s); dis[s] = 0; // 初始化：把s点作为起点，s点到s点的距离为0 while(q.size()){ int u = q.front(); q.pop(); vis[u] = false; // 取出队首，把队首从队列q中弹出并标记 for (int i = 0; i &lt; edge[u].size(); ++i){ if (dis[edge[u][i].to] &gt; dis[u] + edge[u][i].val){ dis[edge[u][i].to] = dis[u] + edge[u][i].val; // 更新到edge[u][i].to点的距离 if (vis[edge[u][i].to] == false){ vis[edge[u][i].to] = true; q.push(edge[u][i].to); // 如果不在队列q中则加入队列q并标记 } } } }}int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1; i &lt;= m; ++i){ cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; t.to = v; t.val = w; edge[u].push_back(t); // 添加一条有向边 } spfa(); for (int i = 1; i &lt;= n; ++i){ cout &lt;&lt; dis[i] &lt;&lt; &quot; &quot;; // 输出从s点到各点的最短路径 } return 0;}","link":"/2023/10/01/spfa/"}],"tags":[{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"OI备忘录","slug":"OI备忘录","link":"/tags/OI%E5%A4%87%E5%BF%98%E5%BD%95/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"}],"pages":[{"title":"About Me","text":"一直很菜的信竞选手，爱看书。 在沉重的世界里幻化成轻逸的飞鸟。 ThroughBall 的个人中心 - 洛谷 ThroughBall · GitHub OI备忘录 - 洛谷博客 Throughball - Codeforces I went to the woods because I wished to live deliberately, to front only the essential facts of life, and see if I could not learn what it had to teach, and not, when I came to die, discover that I had not lived.","link":"/about/index.html"}]}