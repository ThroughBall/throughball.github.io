{"posts":[{"title":"CF1499D The Number of Pairs 题解","text":"好久没有写 Blog 了 :u 原题链接 问题是每次给你三个整数 $c,d,x$，要你求有多少对 $(a,b)$ 使得 $c\\times lcm(a,b) - d\\times\\gcd(a,b) = x$ 首先肯定要把 $lcm(a,b)$ 换成 $\\frac{ab}{\\gcd(a,b)}$ 的，这样原式就变成了： $$c\\frac{ab}{\\gcd(a,b)}-d\\gcd(a,b)=x$$ 接下来就不知道怎么操作了？这个式子对我们帮助并不大，因为其中既有 $a,b$ 还有 $\\gcd(a,b)$ 不过我们可以把 $a$ 和 $b$ 用 $\\gcd(a,b)$ 来表示，设 $a = k_{1}\\gcd(a,b),b=k_{2}\\gcd(a,b)$，这里千万要注意一个特殊性质：$k_{1}$ 和 $k_{2}$ 是互质的 把设的式子带回原式再合并同类项一下就可以得到： $$\\gcd(a,b)(ck_{1}k_{2}-d)=x$$ 因为 $k_{1}$ 和 $k_{2}$ 有特殊性质，而 $a,b$ 又用 $\\gcd(a,b)$ 和 $k_{1},k_{2}$ 表示，所以得到上面式子后我们尝试用 $k_{1},k_{2}$ 来表示 $\\gcd(a,b)$ $$\\gcd(a,b)=\\frac{x}{ck_{1}k_{2}- d}$$ 注意这个式子对 $k_{1},k_{2}$ 有约束条件，就是 $ck_{1}k_{2}-d \\mid x$ 至此，题目已经变成了每次给你三个整数 $c,d,x$，要你求有多少对 $(k_{1},k_{2})$ 满足 $k_{1},k_{2}$ 互质且 $ck_{1}k_{2}-d \\mid x$ 继续找性质，设 $ck_{1}k_{2}-d=t$，可得 $k_{1}k_{2}=\\frac{t+d}{c}$，其中 $t \\mid x$，当然这个式子也有约束条件：$c\\mid t+d$ 这时候我们终于可以利用 $\\gcd(k_{1},k_{2})=1$ 这条性质了 将 $\\frac{t+d}{c}$ 按算术基本定理质因数分解，每一质数不是来自 $k_{1}$ 的就是来自 $k_{2}$的，如果有 $p$ 质因数，那就有 $2^p$ 种 $k_{1}$ 和 $k_{2}$ 的组合 顺带一提，求 $\\frac{t+d}{c}$ 的质因数种类我一开始就暴力求（TLE 了）,后来看了 Codeforces 这场的题解，发现题解用预处理方法做的 首先用埃氏筛求出每个数的最小质因子（其实最大质因子也可以，我就是写最大的）并储存 然后统计质因子种类时，用该数除以最小质因子 如果除过后的数的最小质因子和该数相同，那该数质因子种类就和除过后的数的质因子种类一样，反之就在除过后的数的质因子种类加一 说的可能有点绕，但是看代码就明白了，很简洁也很方便实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int MAX_N = 2e7 + 13;int t, c, d, x;int val[MAX_N], max_div[MAX_N];void precompute() { for (int i = 2; i &lt; MAX_N; ++i) { if (!max_div[i]) { for (int j = i; j &lt; MAX_N; j += i) { max_div[j] = i; } } } for (int i = 2; i &lt; MAX_N; ++i) { int j = i / max_div[i]; val[i] = val[j] + (max_div[i] != max_div[j]); } return ;}int main() { ios::sync_with_stdio(false); precompute(); cin &gt;&gt; t; for (int i = 1; i &lt;= t; ++i) { cin &gt;&gt; c &gt;&gt; d &gt;&gt; x; int ans = 0; for (int j = 1; j &lt;= sqrt(x); ++j) { if (x % j == 0) { if (j * j != x) { int num1 = j, num2 = x / j; if ((num1 + d) % c == 0) ans += 1 &lt;&lt; val[(num1 + d) / c]; if ((num2 + d) % c == 0) ans += 1 &lt;&lt; val[(num2 + d) / c]; } else { int num1 = j; if ((num1 + d) % c == 0) ans += 1 &lt;&lt; val[(num1 + d) / c]; } } } cout &lt;&lt; ans &lt;&lt; endl; } return 0;}","link":"/2024/05/01/CF1499D/"},{"title":"P9541 「AWOI Round 2 D」数字三角形 题解","text":"寒假第一题 XD luogu题目链接 不难想到，三角形旋转三遍之后就复原了，而且旋转会加消耗值，所以旋转次数越少越好 那么就只有三种情况，不旋转，旋转一次和旋转两次 给一个三角形，不考虑旋转，按照题意最小消耗值是多少呢？ 因为想要经过数之和最大，所以如果经过一个不是该行最大值的点，那就要消耗 1 个单位，用来把最大值和那个点交换 如果经过的点本来就是该行最大值，那就不需要交换，也不需要加消耗值 所以这题虽然看着像原版数字三角形，但其实是一个每个点不是 0（是该行最大值）就是 1（不是该行最大值）的数字三角形问题 在计算完三角形的消耗值后，我们旋转，再计算，再旋转，再计算 不过注意本题路径经过数之和优先，只有在经过数之和相同的情况下，才会比较消耗值 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define MAXN 1005using namespace std;int tri[MAXN][MAXN], ans_sum, ans_exp, maxtri[MAXN], dp[MAXN][MAXN], n, newtri[MAXN][MAXN];int init() { int sum = 0; memset(maxtri, 0, sizeof(maxtri)); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= i; ++j) { dp[i][j] = 0; } } for (int i = 1; i &lt;= n; ++i) { maxtri[i] = -1; for (int j = 1; j &lt;= i; ++j) { if (tri[i][j] &gt; maxtri[i]) { maxtri[i] = tri[i][j]; } } sum += maxtri[i]; } return sum;} // 初始化，记录每一行的最大值int solve() { for (int i = n - 1; i &gt;= 1; --i) { for (int j = 1; j &lt;= i; ++j) { dp[i][j] = min(dp[i + 1][j] + (maxtri[i + 1] == tri[i + 1][j] ? 0 : 1), dp[i + 1][j + 1] + (maxtri[i + 1] == tri[i + 1][j + 1] ? 0 : 1)); // 如果最大值是该点，就不消耗，否则就+1 } } return dp[1][1];} // 动态规划求三角形中最小消耗void rotate() { for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= i; ++j) { newtri[j - i + n][n - i + 1] = tri[i][j]; } } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= i; ++j) { tri[i][j] = newtri[i][j]; } }} // 模拟三角形旋转int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= i; ++j) { cin &gt;&gt; tri[i][j]; } } for (int i = 1; i &lt;= 3; ++i) { if (init() &gt; ans_sum) { ans_sum = init(); ans_exp = (i - 1) * n + solve(); } else if (init() == ans_sum) { ans_exp = min(ans_exp, (i - 1) * n + solve()); } // 先考虑数字和，数字和相同再比较消耗 rotate(); } cout &lt;&lt; ans_sum &lt;&lt; &quot; &quot; &lt;&lt; ans_exp &lt;&lt; endl; return 0;}","link":"/2024/01/31/P9541/"},{"title":"JOI 2017 Final 足球 题解","text":"luogu题目链接 首先我们注意到运球和移动的疲劳度都是 $C$，而对于运球和控球，人和球都是想向哪走向哪走 考虑踢球的疲劳度 $A×p+B$，我们看作从非踢球状态转变为踢球状态要消耗疲劳度 $B$，此后两点之间的球消耗 $A$ 对于没有人控制的球，它在没有受到球员作用下，要么连续横向移动，要么连续竖向移动 基于以上的性质，我们考虑建三个点 控球（０ 层） 传球时横向移动（１ 层） 传球时纵向移动（２ 层） 对于上下左右相邻的点，我们建以下的边 运球的边$(C)$ 横向移动的边$(A)$ 纵向移动的边$(A)$ 对于点和自己，我们建以下的边 从非踢球状态转变为踢球状态$(B)$ 最近的球员来接这个球$(dis×C)$ 接下来就变成最短路问题了 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt; #include &lt;map&gt;#include &lt;cstring&gt;#define MAXN 100005#define int long long#define MAXH 505using namespace std;int h, w, a, b, c, n, x[MAXN], y[MAXN], cnt;int dis[MAXH][MAXH], dist[MAXH * MAXH * 3];int dij[MAXH * MAXH * 3];int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};bool vis[MAXH][MAXH], vis2[MAXH * MAXH * 3];struct Dist{ int disx; int disy;};struct Node{ int id, d; bool operator &lt; (const Node &amp;x) const{ return d &gt; x.d; }};queue &lt;Dist&gt; q;priority_queue &lt;Node&gt; pq;vector &lt;pair&lt;int, int&gt;&gt; G[MAXH * MAXH * 3];map &lt;tuple&lt;int, int, int&gt;, int&gt; mp;tuple &lt;int, int, int&gt; t[MAXH * MAXH * 3], get_t;bool judge(int ax, int ay){ return ((ax &gt;= 0) &amp;&amp; (ax &lt;= h) &amp;&amp; (ay &gt;= 0) &amp;&amp; (ay &lt;= w));}int getid(int ax, int ay, int f){ if (!mp[make_tuple(ax, ay, f)]){ mp[make_tuple(ax, ay, f)] = ++cnt; t[cnt] = make_tuple(ax, ay, f); } return mp[make_tuple(ax, ay, f)];}void Manhattan_Distance(){ for (int i = 0; i &lt;= h; ++i){ for (int j = 0; j &lt;= w; ++j){ dis[i][j] = 0x7fffffff; } } for (int i = 1; i &lt;= n; ++i){ dis[x[i]][y[i]] = 0; q.push((Dist){x[i], y[i]}); } while(q.size()){ int tbx = q.front().disx; int tby = q.front().disy; q.pop(); vis[tbx][tby] = false; for (int i = 0; i &lt; 4; ++i){ int cntx = tbx + dx[i]; int cnty = tby + dy[i]; if (judge(cntx, cnty) &amp;&amp; dis[cntx][cnty] &gt; dis[tbx][tby] + 1){ dis[cntx][cnty] = dis[tbx][tby] + 1; if (!vis[cntx][cnty]){ q.push((Dist){cntx, cnty}); vis[cntx][cnty] = true; } } } }}void Build_Map(){ for (int i = 0; i &lt;= h; ++i){ for (int j = 0; j &lt;= w; ++j){ int tbid0 = getid(i, j, 0); int tbid1 = getid(i, j, 1); int tbid2 = getid(i, j, 2); for (int k = 0; k &lt; 4; ++k){ int cntx = i + dx[k]; int cnty = j + dy[k]; if (judge(cntx, cnty)){ G[tbid0].push_back(make_pair(getid(cntx, cnty, 0), c)); } } for (int k = 0; k &lt; 2; ++k){ int cntx = i + dx[k]; int cnty = j + dy[k]; if (judge(cntx, cnty)){ G[tbid1].push_back(make_pair(getid(cntx, cnty, 1), a)); } } for (int k = 2; k &lt; 4; ++k){ int cntx = i + dx[k]; int cnty = j + dy[k]; if (judge(cntx, cnty)){ G[tbid2].push_back(make_pair(getid(cntx, cnty, 2), a)); } } G[tbid0].push_back(make_pair(tbid1, b)); G[tbid0].push_back(make_pair(tbid2, b)); G[tbid1].push_back(make_pair(tbid0, dis[i][j] * c)); G[tbid2].push_back(make_pair(tbid0, dis[i][j] * c)); } }}void Dijkstra(){ for (int i = 1; i &lt;= cnt; ++i) dist[i] = 4e18; int tbid = getid(x[1], y[1], 0); dist[tbid] = 0; pq.push((Node){tbid, 0}); while(pq.size()){ int idcnt = pq.top().id; pq.pop(); if (vis2[idcnt]) continue; vis2[idcnt] = true; for (unsigned int i = 0; i &lt; G[idcnt].size(); ++i){ int idnum = G[idcnt][i].first; int tbdis = G[idcnt][i].second; if (dist[idcnt] + tbdis &lt; dist[idnum]){ dist[idnum] = dist[idcnt] + tbdis; get_t = t[idnum]; pq.push((Node){getid(get&lt;0&gt;(get_t), get&lt;1&gt;(get_t), get&lt;2&gt;(get_t)), dist[idnum]}); } } }}signed main(){ scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;, &amp;h, &amp;w, &amp;a, &amp;b, &amp;c, &amp;n); for (int i = 1; i &lt;= n; ++i){ scanf(&quot;%lld%lld&quot;, &amp;x[i], &amp;y[i]); } Manhattan_Distance(); Build_Map(); Dijkstra(); printf(&quot;%lld&quot;, min(min(dist[getid(x[n], y[n], 0)], dist[getid(x[n], y[n], 1)]), dist[getid(x[n], y[n], 2)])); return 0;}","link":"/2023/11/26/P5100/"}],"tags":[{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"OI备忘录","slug":"OI备忘录","link":"/tags/OI%E5%A4%87%E5%BF%98%E5%BD%95/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"JOI","slug":"JOI","link":"/tags/JOI/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"}],"pages":[{"title":"About Me","text":"在沉重的世界里幻化成轻逸的飞鸟。 个人邮箱：throughball1@outlook.com 其他平台的账号： ThroughBall 的个人中心 - 洛谷 ThroughBall · GitHub Throughball - Codeforces Throughball - Atcoder","link":"/about/index.html"}]}