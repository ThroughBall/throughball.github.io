{"posts":[{"title":"JOI 2017 Final 足球 题解","text":"luogu题目链接 首先我们注意到运球和移动的疲劳度都是C，而对于运球和控球，人和球都是想向哪走向哪走 考虑踢球的疲劳度$A×p+B$，我们看作从非踢球状态转变为踢球状态要消耗疲劳度B，此后两点之间的球消耗A 对于没有人控制的球，它在没有受到球员作用下，要么连续横向移动，要么连续竖向移动 基于以上的性质，我们考虑建三个点 控球（０层） 传球时横向移动（１层） 传球时纵向移动（２层） 对于上下左右相邻的点，我们建以下的边 运球的边$(C)$ 横向移动的边$(A)$ 纵向移动的边$(A)$ 对于点和自己，我们建以下的边 从非踢球状态转变为踢球状态$(B)$ 最近的球员来接这个球$(dis×C)$ 接下来就变成最短路问题了 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt; #include &lt;map&gt;#include &lt;cstring&gt;#define MAXN 100005#define int long long#define MAXH 505using namespace std;int h, w, a, b, c, n, x[MAXN], y[MAXN], cnt;int dis[MAXH][MAXH], dist[MAXH * MAXH * 3];int dij[MAXH * MAXH * 3];int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};bool vis[MAXH][MAXH], vis2[MAXH * MAXH * 3];struct Dist{ int disx; int disy;};struct Node{ int id, d; bool operator &lt; (const Node &amp;x) const{ return d &gt; x.d; }};queue &lt;Dist&gt; q;priority_queue &lt;Node&gt; pq;vector &lt;pair&lt;int, int&gt;&gt; G[MAXH * MAXH * 3];map &lt;tuple&lt;int, int, int&gt;, int&gt; mp;tuple &lt;int, int, int&gt; t[MAXH * MAXH * 3], get_t;bool judge(int ax, int ay){ return ((ax &gt;= 0) &amp;&amp; (ax &lt;= h) &amp;&amp; (ay &gt;= 0) &amp;&amp; (ay &lt;= w));}int getid(int ax, int ay, int f){ if (!mp[make_tuple(ax, ay, f)]){ mp[make_tuple(ax, ay, f)] = ++cnt; t[cnt] = make_tuple(ax, ay, f); } return mp[make_tuple(ax, ay, f)];}void Manhattan_Distance(){ for (int i = 0; i &lt;= h; ++i){ for (int j = 0; j &lt;= w; ++j){ dis[i][j] = 0x7fffffff; } } for (int i = 1; i &lt;= n; ++i){ dis[x[i]][y[i]] = 0; q.push((Dist){x[i], y[i]}); } while(q.size()){ int tbx = q.front().disx; int tby = q.front().disy; q.pop(); vis[tbx][tby] = false; for (int i = 0; i &lt; 4; ++i){ int cntx = tbx + dx[i]; int cnty = tby + dy[i]; if (judge(cntx, cnty) &amp;&amp; dis[cntx][cnty] &gt; dis[tbx][tby] + 1){ dis[cntx][cnty] = dis[tbx][tby] + 1; if (!vis[cntx][cnty]){ q.push((Dist){cntx, cnty}); vis[cntx][cnty] = true; } } } }}void Build_Map(){ for (int i = 0; i &lt;= h; ++i){ for (int j = 0; j &lt;= w; ++j){ int tbid0 = getid(i, j, 0); int tbid1 = getid(i, j, 1); int tbid2 = getid(i, j, 2); for (int k = 0; k &lt; 4; ++k){ int cntx = i + dx[k]; int cnty = j + dy[k]; if (judge(cntx, cnty)){ G[tbid0].push_back(make_pair(getid(cntx, cnty, 0), c)); } } for (int k = 0; k &lt; 2; ++k){ int cntx = i + dx[k]; int cnty = j + dy[k]; if (judge(cntx, cnty)){ G[tbid1].push_back(make_pair(getid(cntx, cnty, 1), a)); } } for (int k = 2; k &lt; 4; ++k){ int cntx = i + dx[k]; int cnty = j + dy[k]; if (judge(cntx, cnty)){ G[tbid2].push_back(make_pair(getid(cntx, cnty, 2), a)); } } G[tbid0].push_back(make_pair(tbid1, b)); G[tbid0].push_back(make_pair(tbid2, b)); G[tbid1].push_back(make_pair(tbid0, dis[i][j] * c)); G[tbid2].push_back(make_pair(tbid0, dis[i][j] * c)); } }}void Dijkstra(){ for (int i = 1; i &lt;= cnt; ++i) dist[i] = 4e18; int tbid = getid(x[1], y[1], 0); dist[tbid] = 0; pq.push((Node){tbid, 0}); while(pq.size()){ int idcnt = pq.top().id; pq.pop(); if (vis2[idcnt]) continue; vis2[idcnt] = true; for (unsigned int i = 0; i &lt; G[idcnt].size(); ++i){ int idnum = G[idcnt][i].first; int tbdis = G[idcnt][i].second; if (dist[idcnt] + tbdis &lt; dist[idnum]){ dist[idnum] = dist[idcnt] + tbdis; get_t = t[idnum]; pq.push((Node){getid(get&lt;0&gt;(get_t), get&lt;1&gt;(get_t), get&lt;2&gt;(get_t)), dist[idnum]}); } } }}signed main(){ scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;, &amp;h, &amp;w, &amp;a, &amp;b, &amp;c, &amp;n); for (int i = 1; i &lt;= n; ++i){ scanf(&quot;%lld%lld&quot;, &amp;x[i], &amp;y[i]); } Manhattan_Distance(); Build_Map(); Dijkstra(); printf(&quot;%lld&quot;, min(min(dist[getid(x[n], y[n], 0)], dist[getid(x[n], y[n], 1)]), dist[getid(x[n], y[n], 2)])); return 0;}","link":"/2023/11/26/P5100/"}],"tags":[{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"OI备忘录","slug":"OI备忘录","link":"/tags/OI%E5%A4%87%E5%BF%98%E5%BD%95/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"}],"pages":[{"title":"About Me","text":"在沉重的世界里幻化成轻逸的飞鸟。 个人邮箱：throughball1@outlook.com 其他平台的账号： ThroughBall 的个人中心 - 洛谷 ThroughBall · GitHub Throughball - Codeforces Throughball - Atcoder","link":"/about/index.html"}]}